---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: publish-to-cgw
  labels:
    app.kubernetes.io/version: "0.1.0"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >-
    Tekton task to publish content to CGW (Content-Gateway)
  params:
    - name: cgwHostname
      type: string
      description: >
        The hostname of the content-gateway to publish the metadata to
      default: https://developers.redhat.com/content-gateway/rest/admin
    - name: cgwSecret
      type: string
      description: >
        The kubernetes secret to use to authenticate to content-gateway.
        It needs to contain two keys: username and token
      default: exodus-prod-secret
    - name: dataPath
      type: string
      description: >
        Path to the JSON string of the merged data to use in the data workspace.
    - name: binariesDir
      type: string
      description: Path where the binaries are stored in the workspace
      default: exodus-prod-secret # Default secret to use
    - name: subdirectory
      description: Subdirectory inside the workspace to be used
      type: string
      default: ""
  workspaces:
    - name: data
      description: Workspace to save the CR jsons to
  steps:
    - name: create-cgw-metadata-file
      image: quay.io/konflux-ci/release-service-utils:38c3bfd7479c86b832cba5b61f9bbde40c469393
      script: |
        #!/usr/bin/env python3
        """
        Generate a YAML file for `push-cgw-metadata` to use:
        1. Extract all components under contentGateway key from dataPath.
        2. Find all the files in binariesDir that starts with the component name
        4. Generate necessary metadata for each file
        5. Dump the metadata to a YAML file
        """
        import os
        import json
        import yaml
        import hashlib

        DATA_FILE = "$(workspaces.data.path)/$(params.dataPath)"
        BINARIES_DIR = "$(workspaces.data.path)/$(params.binariesDir)"
        with open(DATA_FILE, 'r') as file:
            data = json.load(file)

        productName = data['contentGateway']['productName']
        productCode = data['contentGateway']['productCode']
        productVersionName = data['contentGateway']['productVersionName']

        # Default values for each component, 
        # values from DATA_FILE takes presedence over these
        default_values_per_component = {
            'type': "FILE",
            'shortURL': f"cgw/{productCode}",
            "hidden": "false",
            "invsible": "false",
        }

        def generate_download_url(file_name):
            """
            Generate a download URL in this format: 
            exodus:/content/origin/files/sha256/{checksum[:2]}{checksum}/{file_name}
            """
            prefix = "exodus:/content/origin/files/sha256"
            sha256_hash = hashlib.sha256()
            with open(BINARIES_DIR + "/" + file_name, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            checksum = sha256_hash.hexdigest()
            return f"{prefix}/{checksum[:2]}/{checksum}/{file_name}"

        def generate_label(component):
            """
            Generate a label for the component
                TODO: We will want some additional logic here for checksum.txt files
            """
            name = component['name']
            return name

        valid_components = []
        binaries_list = os.listdir(BINARIES_DIR)
        print(f"Binaries list: {binaries_list}")
        components = data['contentGateway']['components']

        for component in components:
            updated_component = component.copy()
            for file in binaries_list:
                if file.startswith(component['name']):
                    updated_component.update({
                        'productName': productName,
                        'productCode': productCode,
                        'productVersionName': productVersionName,
                        'downloadUrl': generate_download_url(file),
                        'label': generate_label(component),
                    })
                    if 'name' in updated_component:
                        del updated_component['name']
                    final_component = {**default_values_per_component, **updated_component}
                    valid_components.append({
                        'type': 'file',
                        'action': 'create',
                        'metadata': final_component
                    })

        metadata_file = "$(workspaces.data.path)/cgw_metadata.yaml"

        with open(metadata_file, 'w') as file:
            yaml.dump(valid_components, file, default_flow_style=False, sort_keys=False)

        print(f"YAML content dumped to {metadata_file}")

        with open(metadata_file, 'r') as file:
            print(file.read())
    - name: run-push-cgw-metadata
      image: quay.io/konflux-ci/release-service-utils:38c3bfd7479c86b832cba5b61f9bbde40c469393
      env:
        - name: CGW_USERNAME
          valueFrom:
            secretKeyRef:
              name: $(params.cgwSecret)
              key: username
        - name: CGW_TOKEN
          valueFrom:
            secretKeyRef:
              name: $(params.cgwSecret)
              key: token
      script: |
        #!/usr/bin/sh
        set -x
        
        CGW_FILEPATH="$(workspaces.data.path)/$(params.subdirectory)/cgw_metadata.yaml"
        if [ ! -f "$CGW_FILEPATH" ]; then
            echo "Metadata file not found"
            exit 1
        fi

        # { set +x; } 2>/dev/null
        # OUTPUT=$(push-cgw-metadata --CGW_hostname "$(params.cgwHostname)" --CGW_username "${CGW_USERNAME}" --CGW_password "${CGW_TOKEN}" --CGW_filepath "${CGW_FILEPATH}")
        # { set -x; } 2>/dev/null
        # echo "$OUTPUT"
